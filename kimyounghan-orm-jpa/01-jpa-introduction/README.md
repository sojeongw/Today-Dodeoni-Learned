# JPA 소개

## SQL 중심적인 개발의 문제점
### SQL에 의존적인 개발

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.04.45.png)

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.04.53.png)

객체를 관계형 DB에 관리해야 한다. 그러다보니 SQL 중심으로 개발이 된다. 모든 쿼리를 다 짜고 자바 객체를 SQL로, SQL을 자바 객체로 변환하는 지루한 코드를 무한 반복해야한다.

### 패러다임의 불일치

객체는 필드와 메서드를 잘 캡슐화해서 사용하는 것이, RDBMS는 데이터를 잘 정규화 해서 저장하는 것이 목표다. 즉 서로 다른 성격이기 때문에 사용하기가 힘들다. 결국 개발자가 SQL 매퍼의 일을 하게 된다.

## 객체와 관계형 데이터베이스의 차이

- 상속
  - 객체에는 있지만 데이터베이스에는 없다.
- 연관 관계
  - 객체는 참조를 통해 데이터를 가져오지만 데이터베이스는 PK, FK로 조인을 해서 가져온다.
- 데이터 타입
- 테이터 식별 방법

### 상속

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.12.19.png)

객체의 상속 관계를 비슷하게 구현할 수 있는 것이 슈퍼 타입, 서브 타입이라는 물리 모델이다. 

이걸 테이블에 저장하려면 객체를 분해한 다음 `insert into item`, `insert into album` 이렇게 쿼리를 여러 번 쳐야 한다. 조회를 한다고 하면 join을 가지고 album이나 movie에 맞게 만들어줘야 한다. 이렇게 번잡해지는 문제가 있다.

```java
list.add(album);
Album album = list.get(albumId);
Item item = list.get(albumId);
```

만약 자바 컬렉션이라면 위처럼 쉽게 할 수 있다. 하지만 RDMBS에 저장하고 꺼내는 순간 번잡한 일이 되는 것이다.

### 연관 관계

```java
member.getTeam();
```

객체는 참조를 사용한다.

```sql
join on m.team_id = t.team_id
```

테이블은 외래 키를 가용한다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.20.04.png)

문제는 Team에서 Member 객체를 조회할 수 없다는 것이다. 테이블은 PK만 있으면 반대로도 조인할 수 있다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.22.09.png)

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.22.15.png)

코드로 구현하면 위와 같이 매핑할 수 있을 것이다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.23.36.png)

근데 객체답게 설계한다면 사실 Member는 teamId가 아니라 team을 참조해야 하는 것 같다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.23.42.png)

DB에 insert하려고 하니 team_id가 필요하다. member에서 `getTeam()`을 통해 id를 찾아준다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.23.47.png)

문제는 조회다. 멤버와 팀을 각각 조회해서 연관 관계를 코드로 직접 설정해줘야 하는 번거로움이 있다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.23.53.png)

자바 컬렉션에 넣는다고 하면 팀이 다 컬렉션에 들어가니까 연관된 데이터가 한 줄에 딸려온다. 하지만 DB에 넣는 순간 이게 망가져버린다.

### 객체 그래프 탐색

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.29.20.png)

객체는 레퍼런스만 있으면 어디든 쭉쭉 갈 수 있어야 한다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.29.20.png)

하지만 처음 실행하는 SQL에 따라 검색할 수 있는 범위가 제한되어 버린다. SQL에서는 member와 team만 있기 때문에 값을 채울 수가 없다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.29.20.png)

이것은 결국 엔티티 신뢰 문제로 번진다. 실제 데이터를 확인하기 전까지는 엔티티를 신뢰할 수가 없다. 레이어드 아키텍쳐는 그 다음 계층을 신뢰하고 있어야 하는데 이게 깨지는 것이다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.29.20.png)

그렇다고 모든 객체를 미리 다 끌어올 수도 없는 일이다. 그래서 경우의 수에 따라 위처럼 조회하는 메서드를 여러 개 만들어야 한다.

이렇게 물리적으로는 서비스와 DAO 계층이 나뉘어 있어도 논리적으로는 연결되어 있는 문제가 있다. 즉, 진정한 의미의 계층 분할이 어렵다.

### 데이터 식별 방법

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.34.25.png)

식별자가 같아도 SQL 실행 결과를 `new Member()`를 통해 새로 만들기 때문에 비교하면 다르게 나온다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.34.30.png)

하지만 컬렉션에서 조회한다면 같게 나온다.

----

따라서 객체 지향 설계를 하면 할 수록 매핑 작업만 늘어난다. 이에 대한 대안이 JPA다.

## ORM

객체는 객체대로 설계하고 관계형 데이터베이스는 그대로 설계해서 ORM 프레임워크가 매핑해준다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.42.11.png)

JPA는 애플리케이션과 JDBC 사이에서 동작한다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.42.51.png)

JPA에게 객체를 넘기면 해당 엔티티를 분석해서 적절한 쿼리를 생성한다. 그 쿼리를 JDBC API에게 보내고 결과를 받는다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.42.59.png)

조회할 때도 PK만 보내면 JPA가 적절한 쿼리를 만들어 보내고 결과를 매핑해준다.

이렇게 패러다임의 불일치를 해결해준다.

## JPA 소개

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.47.10.png)

옛날에도 EJB라는 ORM이 있었지만 성능이나 기능이 좋지 않아 잘 쓰이지 않았다. 그걸 개선한 게 하이버네이트고 자바 진영에서 하이버네이트 개발자를 데려와 표준으로 만든 것이 JPA다.

![](../../.gitbook/assets/kimyounghan-orm-jpa/01/스크린샷%202021-03-12%20오전%209.47.43.png)

JPA는 인터페이스의 모음이다. JPA 2.1 표준 명세를 구현한 구현체는 하이버네이트, EclipseLink, DataNucleus 세 가지가 있다. 대부분은 하이버네이트를 사용한다.