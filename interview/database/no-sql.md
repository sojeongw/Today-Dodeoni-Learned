# NoSQL

NoSQL은 생각보다 오래전에 등장했다. 1998년 카를로 스트로찌가 표준 SQL 인터페이스를 따르지 않은 자신만의 DB를 NoSQL이라고 명명하면서 시작되었다고 한다.

NoSQL이 등장한 이후에도 RDB의 위치는 여전히 공고했다. RDB는 [ACID](https://ko.wikipedia.org/wiki/ACID) 특성으로 정확하고 안정적으로 트랜잭션을 처리하기 때문이다. SQL이라는 언어의 편의성도 한몫 했다.

## NoSQL의 장점

### 분산 저장

하지만 웹이 발달하고 빅데이터가 등장하면서 많은 데이터를 처리하는데 드는 비용이 매우 커지게 되었다. 데이터와 트래픽이 늘어날 수록 한 대에서 실행되도록 설계된 RDB는 하드웨어적으로 큰 비용을 요구했다. 장비의 성능이 좋을 수록 스케일 업 하는 비용이 기하급수적으로 증가하기 때문이다.

RDB의 해결책이 없는 것은 아니다. 샤딩을 이용하면 샤드 키를 기준으로 테이블을 수평 분할하고 서로 다른 클러스터에 저장할 수 있다. 하지만 애플리케이션에서 어떤 데이터를 어떤 클러스터에 처리할 것인지 등 모든 샤딩을 제어해야 한다. 샤드가 여러 개가 되면 트랜잭션, 일관성 등을 제어하는 것도 어려워진다.

NoSQL은 스케일 아웃을 목표로 한다. 즉, 데이터를 여러 대의 컴퓨터에 분산해서 저장한다. 연관된 데이터들이 함께 분산되어 RDB 같은 복잡한 제어가 필요없다.

대신 일관성을 약간 포기하게 된다. 많은 사람들이 동시에 읽고 쓰는 상황에서 성능을 향상시키는 것이 중요해졌고, 분산 환경에서 각 노드가 잘 작동하고 있어도 일부가 고장나면 DB를 사용할 수 없는 문제를 해결해야 했기 때문이다.

### 데이터 일치

RDB의 관계형 튜플 값은 리스트나 중첩된 값을 포함할 수 없고 단순해야 하는 반면, 메모리 내의 데이터 구조는 훨씬 복잡하다. 그래서 메모리 내의 복잡한 구조를 DB에 저장하려면 이것저것 변환 단계를 거쳐야 한다.

ORM 프레임워크가 이런 문제를 해결해주긴 하지만 여전히 관계형 모델과 메모리 데이터 구조간의 데이터 불일치는 존재한다고 한다. 이를 임피던스 미스매치라고 한다.

NoSQL은 메모리 안에 있는 데이터가 어떻게 생겨먹었든 하나의 Aggregation으로 취급해 저장한다. 따라서 ORM 프레임워크도 필요하지 않다.

### Schema-less

NoSQL은 스키마 없이 동작한다. 따라서 데이터 구조를 미리 만들 필요가 없고 언제든지 바꿀 수 있다. 단, DB가 직접 스키마를 관리하지 않을 뿐 데이터 타입에 따라 암묵적으로 생성되는 스키마는 있다. 이 문제로 어떤 값이 있으면 데이터 타입에서 불일치가 발생할 수도 있다.

예를 들어 필드 이름을 `Quantity`라고 했다면 암묵적으로 필드 이름을 `Quantity`로 하겠다는 뜻이 된다. 이 암묵적인 규칙을 무시한다면 `quantity`, `qty` 등으로 저장하게 될 것이다. 이는 `quantity`, `qty`라는 새로운 필드를 추가하는 것과 같다.

NoSQL은 스키마를 강제하지 않기 때문에 암묵적인 스키마에 대해 항상 주의를 기울여야 한다.

## 종류

* Key-Value
* Document
* Column-family
* Graph

그래프 모델을 제외한 나머지 세 모델은 집합-지향\(Aggregate-oriented\) 모델이다.

## 집합-지향 모델

집합은 하나의 연산으로 취급되는 연관된 객체의 모음이다. RDB처럼 ACID 트랜잭션을 한 엔티티에 대해 지원하진 않지만 하나의 집합을 연산할 때는 지원한다.

집햡-지향 DB는 클러스터가 여러 대로 나뉜, 즉 수평적 확장을 적용한 시스템에 적합하다. RDB와는 다르게 연관된 데이터들끼리 같이 묶여서 움직이기 때문이다.

### 장점

* 메모리 내의 자료 구조와 집합 간의 데이터가 잘 일치하기 때문에 RDB처럼 ORM 프레임워크가 필요하지 않다.
* 키나 ID로 쉽게 집합 레코드를 찾아낼 수 있어 데이터의 검색이 아주 쉽다.

### 단점

* JOIN 연산이 불가능하다.
  * 이 떄문에 MongoDB나 Cassandra 등의 DB에서 맵 리듀스 기능을 제공해 JOIN과 유사한 기능을 제공한다.하지만 사용법이 어렵다고 한다.

## Key-Value

가장 단순한 형태의 NoSQL이다. 키와 값이 쌍으로 저장되는데 키는 값에 접근하기 위한 용도로 사용된다. 값은 데이터가 어떤 형태이든지 다 담을 수 있다. 이미지나 비디오도 가능하다.

대표적인 DB는 Memcached, Riak, Redis, Amazon Dynamo DB, LevelDB다.

### 장점

* 수평적 확장이 용이하다.
* API가 간단해 배우기 쉽고 속도가 굉장히 빠르다.

### 단점

* 값의 내용을 이용해 쿼리를 만들 수 없다.
  * 따라서 키로 값을 읽어서 애플리케이션 레벨에서 적절히 처리해야 한다.

## Document

Key-Value에서 진화한 모델이다. 키와 도큐먼트로 저장된다. Value와 다르게 계층적인 도큐먼트로 저장되는 것이다. 어떻게 보면 객체와도 유사하다고 생각할 수 있다. 따라서 한 객체를 여러 테이블에 나눠서 저장할 필요가 없다.

대표적인 DB는 MongoDB, CouchDB, MarkLogic 등이 있다.

### 장점

* 도큐먼트 안에 있는 item으로 쿼리가 가능하다.
  * 다만 Xquery 등의 다른 도큐먼트 질의 언어를 사용해야 한다.
* 객체를 도큐먼트로 바로 저장할 수 있어 객체-관계 매핑이 필요없다.
* Key-Value와 마찬가지로 속도가 빨라 검색에 최적화 되어있다.

### 단점

* 사용이 번거롭다.
* 질의 결과가 JSON이나 xml로 출력되어 SQL과는 다른 쿼리를 써야한다.
* 따라서 익숙해지는 데에 시간이 필요하다.

## Column-Family

다른 모델들이 값을 이용해서 필드를 결정해싿면 이 모델은 키에서 필드를 결정한다. 키는 키 값인 Row와 Column-family, Column-name을 가진다.

연관된 데이터는 같은 Column-family에 저장된다. 데이터 각각은 Column-name을 가진다. RDB로 치면 Attribute가 계층적으로 데이터를 가지고 있는 것이다.

이렇게 저장된 데이터는 하나의 테이블로 표현이 가능하다. 질의는 Row, Column-family, Column-name을 통해 수행된다.

대표적인 DB는 HBase, Cassandra, Hypertable가 있다.

### 장점

* 클러스터링을 쉽게 할 수 있다.
* Time Stamp가 있어 수정된 히스토리를 알 수 있다.
* 값이 바이너리 데이터로 저장되므로 어떤 형태의 데이터라도 저장할 수 있다.

### 단점

* 다른 두 모델과 다르게 Blob\(Binary Large Object, 이미지/비디오/사운드 같은 멀티미디어 객\) 단위로 쿼리를 할 수 없다.
* Schema-less이지만 새로운 필드를 만들 때 드는 비용이 높아 변경하는 것이 어렵다.
  * 따라서 초기에 Row와 Column을 잘 디자인 해야 한다.

## 그래프 모델

그래프 모델은 집합-지향 보다는 관계형 모델에 가깝다. 데이터를 관계와 함께 표현하기 위해 디자인된 모델이다. 집합-지향과는 다르게 ACID 트랜잭션을 지원한다.

데이터를 연속적인 노드, 관계, 특성으로 저장한다. 즉, 그래프 형태로 저장된다. 따라서 질의는 그래프 순회로 진행된다.

관계가 중요한 모델이므로 탐색의 키가 데이터 간의 관계일 떄 적합하다. 예를 들어, 페이스북이나 트위터에서 내 친구의 친구를 찾는 질의를 할 때나 연관된 데이터를 추천해주는 추천 엔진, 패턴 인식에 유용하다.

### 단점

* 클러스터링에 적합하지 않다.
* 질의 언어가 특수해서 배우기 어렵다.

## 의의

NoSQL의 RDB를 완전히 대체할 수는 없다. RDB가 가진 장점이 명확하고 이미 많은 사람들이 익숙해져 있기 때문이다. 하지만 그럼에도 NoSQL의 가치는 높다.

구매 내역이나 게임의 로그 같은 데이터를 다룬다고 해보자. 1초마다 엄청난 양의 데이터가 오가지만 한 번 저장되면 수정할 일은 거의 없다. 그렇다면 굳이 데이터의 일관성을 보장하는 ACID 트랜잭션은 필요하지 않다.

게다가 데이터가 많기 때문에 여러 대의 장비에 빠른 속도로 저장이 가능하다. 데이터가 많이 누적되더라도 얼마든지 수평 확장이 가능하기 때문이다.

실제로 페이스북과 트위터 같은 SNS는 게시글을 저장할 떄 NoSQL을 쓴다고 한다. 매 초에 수백 기가에서 테라 바이트까지 만들어지는 대용량의 데이터를 빠른 시간 안에 처리해야 하기 때문이다. 만약 NoSQL을 사용하지 않는다면 우리는 글 하나 작성할 때마다 한참을 기다려야 할지 모른다. 검색 엔진도 만약 RDB를 사용했다면 단어를 입력할 때마다 상당한 시간이 걸릴 것이다.

하지만 데이터의 일관성을 보장해야 하거나 조인을 여러 번 해야하는 데이터라면 RDB를 사용하는 것이 좋다. NoSQL은 RDB를 대체하기 보다는 상호 보완할 수 있는 존재이므로 목적에 맞게 사용해야 한다.

